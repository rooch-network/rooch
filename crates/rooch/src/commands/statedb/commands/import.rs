// Copyright (c) RoochNetwork
// SPDX-License-Identifier: Apache-2.0

use std::collections::BTreeMap;
use std::fs::File;
use std::io::{BufRead, BufReader, Read};
use std::path::PathBuf;
use std::str::FromStr;
use std::sync::mpsc::{Receiver, SyncSender};
use std::sync::{mpsc, Arc, RwLock};
use std::thread;
use std::time::{Instant, SystemTime};

use anyhow::{Error, Result};
use chrono::{DateTime, Local};
use clap::Parser;
use metrics::RegistryService;
use serde::{Deserialize, Serialize};

use moveos_store::MoveOSStore;
use moveos_types::h256::H256;
use moveos_types::moveos_std::object::{GENESIS_STATE_ROOT, ObjectID, ObjectMeta};
use moveos_types::startup_info::StartupInfo;
use moveos_types::state::{FieldKey, ObjectState};
use moveos_types::state_resolver::StatelessResolver;
use rooch_common::fs::file_cache::FileCacheManager;
use rooch_config::{R_OPT_NET_HELP, RoochOpt};
use rooch_db::RoochDB;
use rooch_genesis::RoochGenesis;
use rooch_types::error::{RoochError, RoochResult};
use rooch_types::rooch_network::RoochChainID;
use smt::{TreeChangeSet, UpdateSet};

use crate::cli_types::WalletContextOptions;
use crate::commands::statedb::commands::{
    GLOBAL_STATE_TYPE_PREFIX, GLOBAL_STATE_TYPE_ROOT, init_job,
};
use crate::commands::statedb::commands::export::ExportID;


use crate::cli_types::WalletContextOptions;
use crate::commands::statedb::commands::export::ExportID;
use crate::commands::statedb::commands::{GLOBAL_STATE_TYPE_PREFIX, GLOBAL_STATE_TYPE_ROOT};

/// Import state data exported by export command.
#[derive(Debug, Parser)]
pub struct ImportCommand {
    #[clap(long, short = 'i')]
    /// import input file, which generated by export command
    pub input: PathBuf,

    #[clap(long = "data-dir", short = 'd')]
    /// Path to data dir, this dir is base dir, the final data_dir is base_dir/chain_network_name
    pub base_data_dir: Option<PathBuf>,

    /// If local chainid, start the service with a temporary data store.
    /// All data will be deleted when the service is stopped.
    #[clap(long, short = 'n', help = R_OPT_NET_HELP)]
    pub chain_id: Option<RoochChainID>,

    #[clap(long, short = 'b', default_value = "1048576")]
    pub batch_size: Option<usize>,

    #[clap(flatten)]
    pub context_options: WalletContextOptions,
}

impl ImportCommand {
    pub async fn execute(self) -> RoochResult<()> {
        let (root, moveos_store, start_time) = init_job(self.base_data_dir, self.chain_id);
        let pre_root_state_root = root.state_root();

        let (tx, rx) = mpsc::sync_channel(2);
        let moveos_store = Arc::new(moveos_store);
        let produce_updates_thread = thread::spawn(move || {
            produce_updates(
                tx,
                &moveos_store,
                self.input.clone(),
                pre_root_state_root,
                self.batch_size.unwrap(),
            )
        });
        let apply_updates_thread = thread::spawn(move || {
            apply_updates_to_state(
                rx,
                moveos_store,
                pre_root_state_root,
                root.size(),
                start_time,
            )
        });
        produce_updates_thread.join().unwrap();
        apply_updates_thread.join().unwrap();

        Ok(())
    }

    fn init(self) -> (ObjectMeta, MoveOSStore, SystemTime) {
        let start_time = SystemTime::now();
        let datetime: DateTime<Local> = start_time.into();

        let opt = RoochOpt::new_with_default(self.base_data_dir, self.chain_id, None).unwrap();
        let registry_service = RegistryService::default();
        let rooch_db =
            RoochDB::init(opt.store_config(), &registry_service.default_registry()).unwrap();
        let genesis = RoochGenesis::load_or_init(opt.network(), &rooch_db).unwrap();
        let root = genesis.genesis_root().clone();
        println!(
            "task progress started at {}, batch_size: {}",
            datetime,
            self.batch_size.unwrap()
        );
        println!("root object: {:?}", root);
        (root, rooch_db.moveos_store, start_time)
    }
}

struct BatchUpdates {
    states: BTreeMap<StateID, UpdateSet<FieldKey, ObjectState>>,
}

#[derive(Debug, Serialize, Deserialize, Clone, Ord, Eq, PartialOrd, PartialEq)]
pub struct StateID {
    pub export_id: ExportID,
    // start state root
    pub pre_state_root: H256,
}

impl StateID {
    pub fn new(export_id: ExportID, pre_state_root: H256) -> Self {
        Self {
            export_id,
            pre_state_root,
        }
    }
}

fn produce_updates(
    tx: SyncSender<BatchUpdates>,
    moveos_store: &MoveOSStore,
    input: PathBuf,
    root_state_root: H256,
    batch_size: usize,
) {
    let file_cache_mgr = FileCacheManager::new(input.clone()).unwrap();
    let mut cache_drop_offset: u64 = 0;

    let mut csv_reader = BufReader::with_capacity(8 * 1024 * 1024, File::open(input).unwrap());
    let mut last_state_id = None;
    loop {
        let mut bytes_read = 0;

        let mut updates = BatchUpdates {
            states: BTreeMap::new(),
        };
        for line in csv_reader.by_ref().lines().take(batch_size) {
            let line = line.unwrap();
            bytes_read += line.len() as u64 + 1; // Add line.len() + 1, assuming that the line terminator is '\n'

            let (v0, v1) = parse_vals_from_line(&line).unwrap();
            match v0 {
                StrOrFieldKey::Str(v0) => {
                    if v0 == GLOBAL_STATE_TYPE_ROOT {
                        // TODO check current statedb root state root
                        continue;
                    }
                    // object or field
                    let export_id: ExportID = match v1 {
                        ExportIdOrObjState::ExportId(export_id) => export_id,
                        _ => panic!("Invalid combination: If v0 is String, v1 must be ExportId"),
                    };
                    // let eventual_state_root = export_id.parent_state_root;
                    // // TODO add cache to avoid duplicate read smt
                    let pre_state_root = get_pre_state_root(
                        moveos_store,
                        root_state_root,
                        export_id.object_id.clone(),
                    )
                    .unwrap();

                    let state_id = StateID::new(export_id, pre_state_root);
                    updates.states.insert(state_id.clone(), UpdateSet::new());
                    last_state_id = Some(state_id);
                    continue;
                }
                StrOrFieldKey::FieldKey(field_key) => {
                    let state: ObjectState = match v1 {
                        ExportIdOrObjState::ObjState(state) => state,
                        _ => {
                            panic!("Invalid combination: If v0 is FieldKey, v1 must be ObjectState")
                        }
                    };
                    let state_id = last_state_id.clone().expect("State ID should have value");
                    let update_set = updates.states.entry(state_id).or_default();
                    update_set.put(field_key, state);
                }
            }
        }
        let _ = file_cache_mgr.drop_cache_range(cache_drop_offset, bytes_read);
        cache_drop_offset += bytes_read;
        if updates.states.is_empty() {
            break;
        }
        tx.send(updates).expect("failed to send updates");
    }

    drop(tx);
}

fn apply_updates_to_state(
    rx: Receiver<BatchUpdates>,
    moveos_store: Arc<MoveOSStore>,
    root_state_root: H256,
    root_size: u64,
    task_start_time: Instant,
) {
    // let mut _count = 0;
    let mut last_state_root = root_state_root;
    while let Ok(batch) = rx.recv() {
        let loop_start_time = SystemTime::now();

        for (state_id, update_set) in batch.states.into_iter() {
            let mut tree_change_set =
                apply_fields(&moveos_store, state_id.pre_state_root, update_set).unwrap();
            let mut nodes: BTreeMap<H256, Vec<u8>> = BTreeMap::new();
            nodes.append(&mut tree_change_set.nodes);
            last_state_root = tree_change_set.state_root;

            apply_nodes(&moveos_store, nodes).expect("failed to apply nodes");

            log::debug!(
                "state_root: {:?}, new state_root: {:?} execpt state_root: {:?}",
                state_id.pre_state_root,
                last_state_root,
                state_id.export_id.state_root
            );
        }

        println!("This bacth cost: {:?}", loop_start_time.elapsed().unwrap());
    }

    finish_import_job(&moveos_store, last_state_root, root_size, task_start_time);
}

fn finish_import_job(
    moveos_store: &MoveOSStore,
    root_state_root: H256,
    root_size: u64,
    task_start_time: Instant,
) {
    // Update Startup Info
    let new_startup_info = StartupInfo::new(root_state_root, root_size);
    moveos_store
        .get_config_store()
        .save_startup_info(new_startup_info)
        .unwrap();

    let startup_info = moveos_store.get_config_store().get_startup_info().unwrap();
    println!(
        "Done in {:?}. New startup_info: {:?}",
        task_start_time.elapsed(),
        startup_info
    );
}

// get previous state root for updating fields:
// update_set(objects) + pre_state_root(parent_state_root*) -> new_state_root
// parent_state_root*: if parent state root is empty, use root_state_root/*GENESIS_STATE_ROOT
fn get_pre_state_root(
    moveos_store: &MoveOSStore,
    root_state_root: H256,
    object_id: ObjectID,
) -> Result<H256> {
    // try to get previous state root from object's parent
    let parent_state_root_opt = match object_id.parent() {
        Some(parent_id) => {
            let state_opt = moveos_store.get_field_at(root_state_root, &parent_id.field_key())?;
            state_opt.map(|state| state.state_root())
        }
        None => Some(root_state_root),
    };
    let state_root = match parent_state_root_opt {
        Some(parent_state_root) => {
            let state_opt = moveos_store.get_field_at(parent_state_root, &object_id.field_key())?;
            match state_opt {
                Some(state) => state.state_root(),
                None => *GENESIS_STATE_ROOT,
            }
        }
        None => *GENESIS_STATE_ROOT,
    };

    Ok(state_root)
}

pub fn apply_fields<I>(
    moveos_store: &MoveOSStore,
    pre_state_root: H256,
    update_set: I,
) -> Result<TreeChangeSet>
where
    I: Into<UpdateSet<FieldKey, ObjectState>>,
{
    let tree_change_set = moveos_store
        .state_store
        .update_fields(pre_state_root, update_set)?;
    Ok(tree_change_set)
}

pub fn apply_nodes(moveos_store: &MoveOSStore, nodes: BTreeMap<H256, Vec<u8>>) -> Result<()> {
    moveos_store.state_store.node_store.write_nodes(nodes)?;
    Ok(())
}

enum StrOrFieldKey {
    Str(String),
    FieldKey(FieldKey),
}

enum ExportIdOrObjState {
    ExportId(ExportID),
    ObjState(ObjectState),
}

pub fn parse_vals_from_line(line: &str) -> Result<(StrOrFieldKey, ExportIdOrObjState)> {
    let (c0, c1) = parse_raw_strings_from_line(line)?;
    let v0 = c0.as_str();
    let v1 = c1.as_str();
    match FieldKey::from_str(v0) {
        Ok(v) => match ObjectState::from_str(v1) {
            Ok(w) => Ok((StrOrFieldKey::FieldKey(v), ExportIdOrObjState::ObjState(w))),
            Err(_) => Err(anyhow::anyhow!(
                "Invalid combination: If v0 is FieldKey, v1 must be ObjectState"
            )),
        },
        Err(_) => {
            if !v0.starts_with(GLOBAL_STATE_TYPE_PREFIX) {
                return Err(anyhow::anyhow!(
                    "Invalid format: If v0 is String, must has prefix {}",
                    GLOBAL_STATE_TYPE_PREFIX
                ));
            }
            match ExportID::from_str(v1) {
                Ok(w) => Ok((
                    StrOrFieldKey::Str(v0.to_string()),
                    ExportIdOrObjState::ExportId(w),
                )),
                Err(_) => Err(anyhow::anyhow!(
                    "Invalid combination: If v0 is String, v1 must be ExportId"
                )),
            }
        }
    }
}

// csv line format: c1,c2
pub fn parse_raw_strings_from_line(line: &str) -> Result<(String, String)> {
    let str_list: Vec<&str> = line.trim().split(',').collect();
    if str_list.len() != 2 {
        return Err(Error::from(RoochError::from(Error::msg(format!(
            "Invalid csv line: {}",
            line
        )))));
    }
    let c1 = str_list[0].to_string();
    let c2 = str_list[1].to_string();
    Ok((c1, c2))
}

// finish import job with new startup update set
pub fn finish_import_job(
    moveos_store: Arc<MoveOSStore>,
    root_size: u64,
    pre_root_state_root: H256,
    task_start_time: Instant,
    new_startup_update_set: Option<Arc<RwLock<UpdateSet<FieldKey, ObjectState>>>>,
) {
    let root_state_root = match new_startup_update_set {
        Some(new_startup_update_set) => {
            let new_startup_update_set = new_startup_update_set.read().unwrap();
            let new_startup_update_set = new_startup_update_set.clone();
            let tree_change_set =
                apply_fields(&moveos_store, pre_root_state_root, new_startup_update_set).unwrap();
            apply_nodes(&moveos_store, tree_change_set.nodes).unwrap();
            tree_change_set.state_root
        }
        None => pre_root_state_root,
    };
    // Update Startup Info
    let new_startup_info = StartupInfo::new(root_state_root, root_size);
    moveos_store
        .get_config_store()
        .save_startup_info(new_startup_info.clone())
        .unwrap();z
    println!(
        "Done in {:?}. New startup_info: {:?}",
        task_start_time.elapsed(),
        new_startup_info
    );
}

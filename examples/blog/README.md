# README

English | [中文](README_CN.md)

This article mainly introduces how to use a low-code tool to develop a blog sample application.

## Prerequisites

Currently, the [dddappp](https://www.dddappp.org) low-code tool is published as a Docker image for developers to experience.

The off-chain services generated by the tool use Java language and use MySQL database by default. But this article does not intend to explain in detail the deployment and testing of the off-chain services, but mainly introduces how to use Rooch CLI and jq and other command-line tools to query the on-chain state and test contracts.

So before you start experiencing, you need to:

* Install [Rooch CLI](https://github.com/rooch-network/rooch).

* Install [Docker](https://docs.docker.com/engine/install/).

* Install `curl` and `jp` commands (jp - commandline JSON processor). We can use `jp` to process JSON RPC returned JSON results when testing contracts.

* (Optional) Install MySQL database. Can be used to deploy and test off-chain services.

* (Optional) Install JDK and Maven. Used to build and test off-chain services.

## Programming

You can follow the introduction below to reproduce the "programming" process of this sample application. You will find that to develop a complete application, you only need to write very little code. If your application's business logic is just simple CRUD operations on some entities, then you may not even need to write any code other than the "model".

### Write DDDML Model Files 

The low-code dddappp tool we introduced relies on the domain model described by DDDML (Domain-Driven Design Modeling Language) to generate various parts of the application code.

> **Tip**
>
> About DDDML, here is an introductory article: [“Introducing DDDML: The Key to Low-Code Development for Decentralized Applications”](https://github.com/wubuku/Dapp-LCDP-Demo/blob/main/IntroducingDDDML.md). This article contains detailed explanations of some more complex DDDML sample model files.

You can create a directory, for example, named `test`, to place all the application code, and then create a subdirectory `dddml` within this directory. We usually place the model files written according to the DDDML specification in this directory.

Create a plain text file in the `dddml` directory, named `blog.yaml`, with the following content:

```yaml
aggregates:
  Article:
    metadata:
      Preprocessors: [ "MOVE_CRUD_IT" ]
    id:
      name: Id
      type: ObjectID

    properties:
      Title:
        type: String
        length: 200
      Body:
        type: String
        length: 2000
      Comments:
        itemType: Comment
    entities:
      Comment:
        metadata:
          Preprocessors: [ "MOVE_CRUD_IT" ]
        id:
          name: CommentSeqId
          type: u64
        properties:
          Commenter:
            type: String
            length: 100
          Body:
            type: String
            length: 500
          Owner:
            type: address
```

The meaning of this DDDML model should be very clear to developers, but we will still explain it briefly below.

This code defines an aggregate named `Article` and a same-named aggregate root entity, as well as an aggregate internal entity named `Comment`.

Experienced developers should already understand the concept of “entity”.

If you are not very familiar with the DDD concepts of “aggregate”, “aggregate root”, etc., it does not matter. You can first understand the aggregate as “a collection of closely related aggregate root entity and aggregate internal entities”, and understand that “the relationship between the aggregate root and the aggregate internal entities is ‘I own you’”, that's it.

#### "Article" Aggregate

Under the key node `/aggregates/Article/metadata`, we define some metadata to indicate some preprocessors that should be applied when generating code. Here we use the `MOVE_CRUD_IT` preprocessor, which automatically implements the CRUD operation logic for entities.

Under the key node `/aggregates/Article/id`, we define the ID of the article aggregate root. The name of the article ID is `Id`, and the type is `ObjectID`. Here `ObjectID` is a platform-specific type, and we assume that we are developing a decentralized application based on Rooch.

Under the key node `/aggregates/Article/properties`, we define the properties of the article, which represent the title, body, and comments of the article.

The `Title` property of the article is a property of type String with a length limit of 200 characters.

The `Body` property of the article is a property of type String with a length limit of 2000 characters.

The `Comments` property of the article is a collection (`itemType: Comment`) of elements of type `Comment`. Here `Comment` is an internal entity of the aggregate.

#### "Comment" Entity

Under the key node `/aggregates/Article/entities/Comment`, we define the "comment" internal entity of the aggregate.

The `id` of the comment (aggregate internal entity) defined here is a local ID, which only needs to ensure that this ID value is unique among different comments within the same article.

We name the comment ID as `CommentSeqId` and declare its type as `u64`.

Under the key node `/aggregates/Article/entities/Comment/metadata` we also define some metadata, using the same `MOVE_CRUD_IT` preprocessor to give comment entities their own CRUD operations.

Under the key node `/aggregates/Article/entities/Comment/properties` we define the properties of comment, which represent the commenter and comment content.

The `Commenter` property is a property of type `String` with a length limit of 100 characters.

The `Body` property is a property of type `String` with a length limit of 500 characters.

### Run dddappp Project Creation Tool

Use Docker to run the project creation tool:

```shell
docker run \
-v /PATH/TO/test:/myapp \
wubuku/dddappp-rooch:0.0.1 \
--dddmlDirectoryPath /myapp/dddml \
--boundedContextName Test.RoochBlogDemo \
--roochMoveProjectDirectoryPath /myapp/move \
--boundedContextRoochPackageName RoochBlogDemo \
--boundedContextRoochNamedAddress rooch_examples \
--boundedContextJavaPackageName org.test.roochblogdemo \
--javaProjectsDirectoryPath /myapp/rooch-java-service \
--javaProjectNamePrefix roochblogdemo \
--pomGroupId test.roochblogdemo
```

The command parameters above are straightforward:

* Note that `/PATH/TO/test` should be replaced with the path of the local directory where you actually place the application code. This line indicates mounting the local directory into the `/myapp` directory inside the container.
* `dddmlDirectoryPath` is the directory where the DDDML model files are located. It should be a directory path that can be read in the container.
* Understand the value of the `boundedContextName` parameter as the name of the application you want to develop. When the name has multiple parts, separate them with dots and use the PascalCase naming convention for each part. Bounded-context is a term in Domain-driven design (DDD) that refers to a specific problem domain scope that contains specific business boundaries, constraints, and language. If you cannot understand this concept for now, it is not a big deal.
* `roochMoveProjectDirectoryPath` is the directory path where the on-chain Rooch contract code is placed. It should be a readable and writable directory path in the container.
* `boundedContextRoochPackageName` is the package name of the on-chain Rooch contract. It is recommended to use PascalCase naming style.
* `boundedContextRoochNamedAddress` is the default named address of the on-chain Rooch contracts. It is recommended to use snake_case naming style.
* `boundedContextJavaPackageName` is the Java package name of the off-chain service. According to Java naming conventions, it should be all lowercase and the parts should be separated by dots.
* `javaProjectsDirectoryPath` is the directory path where the off-chain service code is placed. The off-chain service consists of multiple modules (projects). It should be a readable and writable directory path in the container.
* `javaProjectNamePrefix` is the name prefix of each module of the off-chain service. It is recommended to use an all-lowercase name.
* `pomGroupId` is the Maven GroupId of the off-chain service. We use Maven as the project management tool for off-chain service. It should be all lowercase and the parts should be separated by dots.

After the above command is successfully executed, two directories `move` and `rooch-java-service` should be added to the local directory `/PATH/TO/test`.

### Project Source Code Structure

Go into the `move` directory, which holds the Move contract items generated from the model. Execute the Move compile command:

```shell
rooch move build --named-addresses rooch_examples={ACCOUNT_ADDRESS}
```

If there are no surprises, the contract project can be built successfully (the last line of the output should show `Success`), but there should be some compilation warnings at this time. That's because some Move source files ending with `_logic.move` have imported (`use`) some modules that are not actually used.

At this point, you can also try to compile the off-chain service. Enter the directory `rooch-java-service` and execute `mvn compile`. If there are no surprises, the compilation should be successful.

#### Contract Project Source Code Structure

In the `move/sources` directory, all the Move source code of the on-chain contract project is included. We first ignore the files ending with `_logic.move` and introduce the other files.

* `rooch_blog_demo_init.move`. It contains the `initialize` function of the on-chain contract. Generally speaking, after the contract project is deployed on-chain, you need to call it first (only need to call it once). However, because our example project is relatively simple, so there is no meaningful initialization logic in the `initialize` function generated by the tool at present, we can ignore it for now.
* `article_aggregate.move`This is where the entry functions are located. Now it contains functions for Create, Update, Delete operations on articles and comments. You can see that the function for creating comments, an internal entity of the aggregate, is named `add_comment` instead of `create_comment`, and the function for deleting comments is named `remove_comment` instead of `delete_comment`. This is actually to make it easier to distinguish these functions as operations on internal entities of the aggregate, rather than operations on the aggregate root itself.
* `article.move`. This file contains the definition of the "data model" of the `Article` aggregate root, as well as the definition of events related to the "article" aggregate.
* `comment.move` This file contains the definition of the "data model" of the `Comment` internal entity of the aggregate.
* The following Move files do not have any complex logic, they just provide some functions that allow you to more conveniently get event property (field) values.
  * `article_created.move`
  * `article_deleted.move`
  * `article_updated.move`
  * `comment_added.move`
  * `comment_removed.move`
  * `comment_updated.move`

#### Business Logic Code

The Move source files ending with `_logic.move` are where the "business logic" implementation code is located.

If you define a method for an aggregate in a DDDML file, then dddappp tool will generate a corresponding Move code file named `{aggregate_name_method_name}_logic.move` for you, and then you need to fill in "business logic" implementation code in this file.

However, we use a preprocessor called `MOVE_CRUD_IT` above to go one step further and automatically generate default implementations for simple CRUD methods. Of course, we can check these "filled-in default logics" and modify them as needed.

After generating a project using the above model, there are already existing "business logic" code files:

* `article_create_logic.move`
* `article_delete_logic.move`
* `article_update_logic.move`
* `article_add_comment_logic.move`
* `article_remove_comment_logic.move`
* `article_update_comment_logic.move`

Now open them and remove those redundant `use` statements. If your IDE has some Move language plugins installed, you may only need to use the "format" feature to reformat these source files.

Then use `rooch move build` command to recompile Move project. Now there should be no warning messages.

Now you can start testing this app.

## Test the Application

### Run Rooch Server and Publish Contracts

First, run a local Rooch server:

```shell
rooch server start
```

Publish Move contracts:

```shell
rooch move publish --named-addresses rooch_examples={ACCOUNT_ADDRESS}
```

When you see something like this output (`status` is `executed`), you can confirm that the publish operation has been executed successfully:

```shell
{
  //...
  "execution_info": {
    //...
    "status": {
      "type": "executed"
    }
  },
  //...
}
```

### Use CLI Tools to Test Contracts

We will use Rooch CLI and other command line tools (`curl`, `jq`) to test the published contracts below.

Use `rooch move run` command to submit a transaction and initialize the contract (note to replace the placeholder `{ACCOUNT_ADDRESS}` with one of your account addresses):

```shell
rooch move run --function {ACCOUNT_ADDRESS}::rooch_blog_demo_init::initialize --sender-account {ACCOUNT_ADDRESS}
```

#### CRUD Articles

##### Create Articles

You can use Rooch CLI to submit a transaction like this to create a test article:

```shell
rooch move run --function {ACCOUNT_ADDRESS}::article_aggregate::create --sender-account {ACCOUNT_ADDRESS} --args 'string:Hello' 'string:World!''
```

Then you can change the content of the first parameter (title) and the second parameter (body) after `--args`, and create a few more articles. The third argument indicates the owner of the article, only the owner can update and delete the article.

##### READ Articles

Now, you can query events and get the `ObjectID` of the created article:

```shell
curl --location --request POST 'http://localhost:50051' \
--header 'Content-Type: application/json' \
--data-raw '{
 "id":101,
 "jsonrpc":"2.0",
 "method":"rooch_getEventsByEventHandle",
 "params":["{ACCOUNT_ADDRESS}::article::ArticleCreated", null, 1000]
}'
```

You can add a pipe operation (` | jq '.result.data[0].parsed_event_data.value.id.value.vec[0]'` at the end of the above command to quickly filter out the ObjectID of the first article.

> **Tip**
>
> Before using the `jp` command (jq - commandline JSON processor), you may need to install it on your machine first.

The command with `jp` processing looks like this:

```shell
curl --location --request POST 'http://localhost:50051' \
--header 'Content-Type: application/json' \
--data-raw '{
 "id":101,
 "jsonrpc":"2.0",
 "method":"rooch_getEventsByEventHandle",
 "params":["{ACCOUNT_ADDRESS}::article::ArticleCreated", null, 1000]
}' | jq '.result.data[0].parsed_event_data.value.id.value.vec[0]'
```

Then, you can use Rooch CLI to query the object state (note to replace the placeholder `{ARTICLE_OBJECT_ID}` with the ObjectID of the article obtained above):

```shell
rooch object --id {ARTICLE_OBJECT_ID}
```

##### Update Articles

You can submit a transaction like this to update an article:

```shell
rooch move run --function {ACCOUNT_ADDRESS}::article_aggregate::update --sender-account {ACCOUNT_ADDRESS} --args 'object_id:{ARTICLE_OBJECT_ID}' 'string:Foo' 'string:Bar''
```

In addition to using Rooch CLI, you can also query the object state by calling JSON RPC:

```shell
curl --location --request POST 'http://127.0.0.1:50051/' \
--header 'Content-Type: application/json' \
--data-raw '{
 "id":101,
 "jsonrpc":"2.0",
 "method":"rooch_getAnnotatedStates",
 "params":["/object/{ARTICLE_OBJECT_ID}"]
}'
```

##### Delete Articles

You can submit a transaction like this to delete an article:

```shell
rooch move run --function {ACCOUNT_ADDRESS}::article_aggregate::delete --sender-account {ACCOUNT_ADDRESS} --args 'object_id:{ARTICLE_OBJECT_ID}'
```

#### CRUD Comments

##### Add Comments

Let's get the ObjectID of another article (note the path parameter `.result.data[1]` in the `jq` command below, we intend to get the information of the "second" ArticleCreated event):

```shell
curl --location --request POST 'http://localhost:50051' \
--header 'Content-Type: application/json' \
--data-raw '{
 "id":101,
 "jsonrpc":"2.0",
 "method":"rooch_getEventsByEventHandle",
 "params":["{ACCOUNT_ADDRESS}::article::ArticleCreated", null, 1000]
}' | jq '.result.data[1].parsed_event_data.value.id.value.vec[0]'
```

Then, we can use this article's ObjectID to add a comment to it (note to replace the placeholder `{ARTICLE_OBJECT_ID}` with the ObjectID of the "second" article obtained above):

```shell
rooch move run --function {ACCOUNT_ADDRESS}::article_aggregate::add_comment --sender-account {ACCOUNT_ADDRESS} --args 'object_id:{ARTICLE_OBJECT_ID}' 'u64:1' 'string:Anonymous' 'string:"A test comment"' 'address:{ACCOUNT_ADDRESS}'
```

We can add a few more comments to this article by executing commands like this (note to modify the second parameter after `--args`, which is the comment sequence number):

```shell
rooch move run --function {ACCOUNT_ADDRESS}::article_aggregate::add_comment --sender-account {ACCOUNT_ADDRESS} --args 'object_id:{ARTICLE_OBJECT_ID}' 'u64:2' 'string:Anonymous2' 'string:"A test comment2"' 'address:{ACCOUNT_ADDRESS}'
```

##### Read Comments

In our contract code, when a comment is added to an article, a `CommentTableItemAdded` event is emitted, which contains the ObjectID of the current article and the key (i.e. `comment_seq_id`) added to its comment table.

So, by querying events, we know which comments an article has:

```shell
curl --location --request POST 'http://localhost:50051' \
--header 'Content-Type: application/json' \
--data-raw '{
 "id":101,
 "jsonrpc":"2.0",
 "method":"rooch_getEventsByEventHandle",
 "params":["{ACCOUNT_ADDRESS}::article::CommentTableItemAdded", null, 10000]
}' | jq '.result.data[] | select(.parsed_event_data.value.article_id == "{ARTICLE_OBJECT_ID}")'
```

In our Move contract, all comments of an article are stored in a field of type `Table<u64, Comment>` embedded in the article object.

We can query the specific information of a comment through JSON RPC. To get an item in a comment table, you need to provide two parameter values: table handle and item key.

First, we need to get the handle of an article's comment table:

```shell
curl --location --request POST 'http://127.0.0.1:50051/' \
--header 'Content-Type: application/json' \
--data-raw '{
 "id":101,
 "jsonrpc":"2.0",
 "method":"rooch_getAnnotatedStates",
 "params":["/object/{ARTICLE_OBJECT_ID}"]
}' | jq '.result[0].move_value.value.value.value.comments.value.handle'
```

We already know that the `comment_seq_id` (i.e. the table item key) of the comment we created above is a `u64` integer value `1`.

Then, we can get the specific information of the comment by the following way (note to replace the placeholder `{COMMENT_TABLE_HANDLE}` with the handle of the "comment table" obtained above):

```shell
curl --location --request POST 'http://127.0.0.1:50051/' \
--header 'Content-Type: application/json' \
--data-raw '{
 "id":101,
 "jsonrpc":"2.0",
 "method":"rooch_getAnnotatedStates",
 "params":["/table/{COMMENT_TABLE_HANDLE}/0x0100000000000000"]
}'
```

Note that in the above command, the table key in the path parameter (the part after `{COMMENT_TABLE_HANDLE}/`), is the BCS serialization result of the key value represented as a hexadecimal string.

For example, the BCS serialization result of a `u64` integer value `1`, represented as a hexadecimal string, is `0x0100000000000000`.

##### Update Comments

We can submit a transaction like this to update a comment:

```shell
rooch move run --function {ACCOUNT_ADDRESS}::article_aggregate::update_comment --sender-account {ACCOUNT_ADDRESS} --args 'object_id:{ARTICLE_OBJECT_ID}' 'u64:1' 'string:Anonymous' 'string:"Updated test comment"' 'address:{ACCOUNT_ADDRESS}'
```

Then we can query the comment state again to see if the comment content has been updated:

```shell
curl --location --request POST 'http://127.0.0.1:50051/' \
--header 'Content-Type: application/json' \
--data-raw '{
 "id":101,
 "jsonrpc":"2.0",
 "method":"rooch_getAnnotatedStates",
 "params":["/table/{COMMENT_TABLE_HANDLE}/0x0100000000000000"]
}'
```

##### Remove Comments

Submit a transaction to remove a comment:

```shell
rooch move run --function {ACCOUNT_ADDRESS}::article_aggregate::remove_comment --sender-account {ACCOUNT_ADDRESS} --args 'object_id:{ARTICLE_OBJECT_ID}' 'u64:1'
```

Execute the `curl` command above to query the comment again, and this time it will return something like this:

```json
{"jsonrpc":"2.0","result":[null],"id":101}
```

~~Because we still have undeleted comments for this article later, trying to delete it now should not succeed. Try executing:~~：

```shell
rooch move run --function {ACCOUNT_ADDRESS}::article_aggregate::delete --sender-account {ACCOUNT_ADDRESS} --args 'object_id:{ARTICLE_OBJECT_ID}'
```

The returned transaction execution status should be failed:

```json
//[TBD]
```

## Using the Off-chain Service

By querying the RESTful API of the off-chain service, you can easily get the detailed information of articles and comments, without using the `curl` and `jp` commands introduced above.

> **Tip**
>
> Since the code of the off-chain service can be quickly regenerated by the dddml tool, we do not include the code of the off-chain service in this code repository.

### Configure and Start Off-chain Service

#### Modify Configuration File

Open the `application-test.yml` file located in the directory `rooch-java-service/roochblogdemo-service-rest/src/main/resources`, find the following lines, and replace the placeholder `{ACCOUNT_ADDRESS}` with your account address:

```yaml
rooch:
  contract:
    address: "{ACCOUNT_ADDRESS}"
    jsonrpc:
      url: "http://127.0.0.1:50051"
```

This is the only place where the off-chain service needs to be configured, and it's that simple.

#### Create Database for Off-chain Service

If you have installed Docker, you can use Docker to run a MySQL database service. For example:

```shell
sudo docker run -p 3306:3306 --name mysql \
-v ~/docker/mysql/conf:/etc/mysql \
-v ~/docker/mysql/logs:/var/log/mysql \
-v ~/docker/mysql/data:/var/lib/mysql \
-e MYSQL_ROOT_PASSWORD=123456 \
-d mysql:5.7
```

Note that in the above command we set the password of the database `root` account to `123456`. The following example shell commands and off-chain service configurations use this root account/password directly. You can modify them according to your running environment.

Use a MySQL client to connect to the local MySQL server and execute the following script to create an empty database (assuming the name is `test2`):

```sql
CREATE SCHEMA `test2` DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_bin;
```

Enter the `rooch-java-service` directory and package the Java project:

```shell
mvn package
```

Then run a command line tool to initialize the database:

```shell
java -jar ./roochblogdemo-service-cli/target/roochblogdemo-service-cli-0.0.1-SNAPSHOT.jar ddl -d "./scripts" -c "jdbc:mysql://127.0.0.1:3306/test2?enabledTLSProtocols=TLSv1.2&characterEncoding=utf8&serverTimezone=GMT%2b0&useLegacyDatetimeCode=false" -u root -p 123456
```

#### Start Off-chain Service

In the `rooch-java-service` directory, execute the following command to start the off-chain service:

```shell
mvn -pl roochblogdemo-service-rest -am spring-boot:run
```

> **Tip**
>
> You can use this Rooch Move CLI cheatsheet!
>
> After starting the off-chain service, you can access this URL to get a cheatsheet on how to use Rooch Move CLI to call on-chain contracts: http://localhost:1023/api/rooch.contract/RoochMoveCLICheatsheet.md
>
> The address of the Move contract you just published has been filled in for you in the cheatsheet. The parameters you need to fill in are some "named" placeholders. You can copy these commands, modify them as needed, and then execute them directly in the command line terminal.

### Off-chain Service RESTful API

Now, you can access this RESTful API to get a list of created articles:

```shell
curl http://localhost:1023/api/Articles
```

You can use parameters to filter the article list, for example:

```shell
curl 'http://localhost:1023/api/Articles?title=Hello'
```

You can access information about a single article like this:

```shell
curl 'http://localhost:1023/api/Articles/{ARTICLE_OBJECT_ID}'
```

## Improve the Application

In the above process, the `MOVE_CRUD_IT` preprocessor already generates the full CRUD methods for us. If CRUD is all the business logic you need, then you don't have to write another line of code.

Of course, when developing a real application, things are often not so simple. Let's move on to explore how we can improve the above example in several points to bring it closer to "actual business requirements".

The final modified model file and Move contract code have been uploaded to this code base. The model file is available at [dddml/blog.yaml](./dddml/blog.yaml) and the code is in the [sources/](./sources/) directory.

### Modify the AddComment Method

It is possible that you feel that the default generated CRUD logic does not meet your needs, for example, you may want to add comment without passing the `Owner` argument to `entry fun add_comment` and directly use the sender account address as the owner, then this requirement can currently be satisfied as follows.

First, define a custom method in the model file like this:

```yaml
aggregates:
  Article:
    # ...
    methods:
      AddComment:
        event:
          name: CommentAdded
          properties:
            Owner:
              type: address
        parameters:
          CommentSeqId:
            type: u64
          Commenter:
            type: String
          Body:
            type: String
```

Note that the `Owner` parameter is no longer present in the method parameters above.

Then, delete `article_add_comment_logic.move`, run the dddappp tool again. (Note that since the tool does not overwrite the already existing `*_logic.move` file by default, you will need to delete it manually.)

Open the regenerated `article_add_comment_logic.move` file, find the `verify` function, fill the function body with the business logic code you want.


### Add a Singleton Object: Blog

We intend to add a singleton object `Blog`, which has a property `Name`, and a property `Articles`, `Articles` being an array of `ObjectID`s representing the posts contained in the blog.

In the `dddml/blog.yaml` file, add the definition of the singleton object:

```yaml
singletonObjects:
  Blog:
    metadata:
      Preprocessors: [ "MOVE_CRUD_IT" ]
    properties:
      Name:
        type: String
        length: 200
      Articles:
        itemType: ObjectID
    methods:
      AddArticle:
        event:
          name: ArticleAddedToBlog
        parameters:
          ArticleId:
            type: ObjectID
      RemoveArticle:
        event:
          name: ArticleRemovedFromBlog
        parameters:
          ArticleId:
            type: ObjectID
```

Run the dddappp tool again. Open the generated `blog_add_article_logic.move` and `blog_remove_article_logic.move` files and fill in the business logic code.

### Modify the Logic of Creating Articles

Open the file `article_create_logic.move`, find the `mutate` function, and modify its implementation so that it adds the newly created article to the `Articles` property of the `Blog` object.

```
    public(friend) fun mutate(
        //...
    ): Object<article::Article> {
        let title = article_created::title(article_created);
        let body = article_created::body(article_created);
        let article_obj = article::create_article(
            storage_ctx,
            title,
            body,
        );
        blog_aggregate::add_article(storage_ctx, _account, article::id(&article_obj));
        article_obj
    }
```

### Modify the Logic of Deleting Articles

Open the file `article_delete_logic.move`, find the `mutate` function, and modify its implementation so that it removes the deleted article from the `Articles` property of the `Blog` object.

```
    public(friend) fun mutate(
        //...
    ): Object<article::Article> {
        let _ = article_deleted;
        blog_aggregate::remove_article(storage_ctx, _account, article::id(&article_obj));
        article_obj
    }
```

### Modify the Logic of Updating Articles

Open the file `article_update_logic.move`, find the `verify` function and modify its implementation to check if the caller is the owner of the article.

```
    const ENOT_OWNER_ACCOUNT: u64 = 113;

    public(friend) fun verify(
        //...
    ): article::ArticleUpdated {
        let _ = storage_ctx;
        assert!(signer::address_of(account) == object::owner(article_obj), ENOT_OWNER_ACCOUNT);
        article::new_article_updated(
            article_obj,
            title,
            body,
        )
    }
```

### Modify Logic of Removing Comments and Updating Comments

Open the file `article_update_comment_logic.move`, find the `verify` function and modify its implementation to check if the caller is the owner of the comment.

```
    const ENOT_OWNER_ACCOUNT: u64 = 113;

    public(friend) fun verify(
        //...
    ): article::CommentUpdated {
        let _ = storage_ctx;
        let comment = article::borrow_comment(article_obj, comment_seq_id);
        assert!(std::signer::address_of(account) == comment::owner(comment), ENOT_OWNER_ACCOUNT);
        article::new_comment_updated(
            //...
        )
    }
```

Open the file `article_remove_comment_logic.move`, find the `verify` function and modify its implementation to check if the caller is the owner of the comment.

```
    const ENOT_OWNER_ACCOUNT: u64 = 113;

    public(friend) fun verify(
        //...
    ): article::CommentRemoved {
        let _ = storage_ctx;
        let comment = article::borrow_comment(article_obj, comment_seq_id);
        assert!(std::signer::address_of(account) == comment::owner(comment), 111);
        article::new_comment_removed(
            //...
        )
    }
```

### Testing the Improved Application

After adding `Blog` as a singleton object, you need to initialize it before creating articles:

```shell
rooch move run --function {ARTICLE_OBJECT_ID}::blog_aggregate::create --sender-account {ARTICLE_OBJECT_ID} --args 'string:My Blog' 'vector<object_id>:{ARTICLE_OBJECT_ID}'
```

Also, you no longer need to pass in the `Owner` argument when adding a comment:

```shell
rooch move run --function {ACCOUNT_ADDRESS}::article_aggregate::add_comment --sender-account {ACCOUNT_ADDRESS} --args 'object_id:{ARTICLE_OBJECT_ID}' 'u64:1' 'string:Anonymous' 'string:"A test comment"'
```

## Other

### A More Complex Rooch Demo

If you are interested, you can find a more complex Rooch Demo here: ["A Rooch Demo"](https://github.com/dddappp/A-Rooch-Demo#configure-off-chain-service).


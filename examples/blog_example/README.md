# README

English | [中文](README_CN.md)

This article mainly introduces how to use a low-code tool to develop a blog sample application.

## Prerequisites

Currently, the dddappp low-code tool is published as a Docker image for developers to experience.

The off-chain services generated by the tool use Java language and use MySQL database by default. But this article does not intend to explain in detail the deployment and testing of the off-chain services, but mainly introduces how to use Rooch CLI and jq and other command-line tools to query the on-chain state and test contracts.

So before you start experiencing, you need to:

* Install [Rooch CLI](https://github.com/rooch-network/rooch).

* Install [Docker](https://docs.docker.com/engine/install/).

* Install `curl` and `jp` commands (jp - commandline JSON processor). We can use `jp` to process JSON RPC returned JSON results when testing contracts.

* (Optional) Install MySQL database. Can be used to deploy and test off-chain services.

* (Optional) Install JDK and Maven. Used to build and test off-chain services.

## Programing

You can follow the introduction below to reproduce the "programming" process of this sample application. You will find that to develop a complete application, you only need to write very little code. If your application's business logic is just simple CRUD operations on some entities, then you may not even need to write any code other than the "model".

### Write DDDML Model Files 

The low-code dddappp tool we introduced relies on the domain model described by DDDML (Domain-Driven Design Modeling Language) to generate various parts of the application code.

> **Tip**
>
> About DDDML, here is an introductory article: [“Introducing DDDML: The Key to Low-Code Development for Decentralized Applications”](https://github.com/wubuku/Dapp-LCDP-Demo/blob/main/IntroducingDDDML.md). This article contains detailed explanations of some more complex DDDML sample model files.

You can create a directory, for example, named `test`, to place all the application code, and then create a subdirectory `dddml` within this directory. We usually place the model files written according to the DDDML specification in this directory.

Create a plain text file in the `dddml` directory, named `blog.yaml`, with the following content:

```yaml
aggregates:
  Article:
    metadata:
      Preprocessors: ["MOVE_CRUD_IT"]
    id:
      name: Id
      type: ObjectID

    properties:
      Title:
        type: String
        length: 200
      Body:
        type: String
        length: 2000
      Comments:
        itemType: Comment

    entities:
      Comment:
        metadata:
          Preprocessors: ["MOVE_CRUD_IT"]
        id:
          name: CommentSeqId
          type: u64
        properties:
          Commenter:
            type: String
            length: 100
          Body:
            type: String
            length: 500
```

The meaning of this DDDML model should be very clear to developers, but we will still explain it briefly below.

This code defines an aggregate named `Article` and a same-named aggregate root entity, as well as an aggregate internal entity named `Comment`.

Experienced developers should already understand the concept of “entity”.

If you are not very familiar with the DDD concepts of “aggregate”, “aggregate root”, etc., it does not matter. You can first understand the aggregate as “a collection of closely related aggregate root entity and aggregate internal entities”, and understand that “the relationship between the aggregate root and the aggregate internal entities is ‘I own you’”, that's it.

#### "Article" Aggregate

Under the key node `/aggregates/Article/metadata`, we define some metadata to indicate some preprocessors that should be applied when generating code. Here we use the `MOVE_CRUD_IT` preprocessor, which automatically implements the CRUD operation logic for entities.

Under the key node `/aggregates/Article/id`, we define the ID of the article aggregate root. The name of the article ID is `Id`, and the type is `ObjectID`. Here `ObjectID` is a platform-specific type, and we assume that we are developing a decentralized application based on Rooch.

Under the key node `/aggregates/Article/properties`, we define the properties of the article, which represent the title, body, and comments of the article.

The `Title` property of the article is a property of type String with a length limit of 200 characters.

The `Body` property of the article is a property of type String with a length limit of 2000 characters.

The `Comments` property of the article is a collection (`itemType: Comment`) of elements of type `Comment`. Here `Comment` is an internal entity of the aggregate.

#### "Comment" Entity

Under the key node `/aggregates/Article/entities/Comment`, we define the "comment" internal entity of the aggregate.

The `id` of the comment (aggregate internal entity) defined here is a local ID, which only needs to ensure that this ID value is unique among different comments within the same article.

We name the comment ID as `CommentSeqId` and declare its type as `u64`.

Under the key node `/aggregates/Article/entities/Comment/metadata` we also define some metadata, using the same `MOVE_CRUD_IT` preprocessor to give comment entities their own CRUD operations.

Under the key node `/aggregates/Article/entities/Comment/properties` we define the properties of comment, which represent the commenter and comment content.

The `Commenter` property is a property of type `String` with a length limit of 100 characters.

The `Body` property is a property of type `String` with a length limit of 500 characters.

### Run dddappp Project Creation Tool

Use Docker to run the project creation tool:

```shell
docker run \
-v /PATH/TO/test:/myapp \
wubuku/dddappp-rooch:0.0.1 \
--dddmlDirectoryPath /myapp/dddml \
--boundedContextName Test.RoochBlogDemo \
--roochMoveProjectDirectoryPath /myapp/move \
--boundedContextRoochPackageName RoochBlogDemo \
--boundedContextRoochNamedAddress rooch_examples \
--boundedContextJavaPackageName org.test.roochblogdemo \
--javaProjectsDirectoryPath /myapp/rooch-java-service \
--javaProjectNamePrefix roochblogdemo \
--pomGroupId test.roochblogdemo
```

The command parameters above are straightforward:

* Note that `/PATH/TO/test` should be replaced with the path of the local directory where you actually place the application code. This line indicates mounting the local directory into the `/myapp` directory inside the container.
* `dddmlDirectoryPath` is the directory where the DDDML model files are located. It should be a directory path that can be read in the container.
* Understand the value of the `boundedContextName` parameter as the name of the application you want to develop. When the name has multiple parts, separate them with dots and use the PascalCase naming convention for each part. Bounded-context is a term in Domain-driven design (DDD) that refers to a specific problem domain scope that contains specific business boundaries, constraints, and language. If you cannot understand this concept for now, it is not a big deal.
* `roochMoveProjectDirectoryPath` is the directory path where the on-chain Rooch contract code is placed. It should be a readable and writable directory path in the container.
* `boundedContextRoochPackageName` is the package name of the on-chain Rooch contract. It is recommended to use PascalCase naming style.
* `boundedContextRoochNamedAddress` is the default named address of the on-chain Rooch contracts. It is recommended to use snake_case naming style.
* `boundedContextJavaPackageName` is the Java package name of the off-chain service. According to Java naming conventions, it should be all lowercase and the parts should be separated by dots.
* `javaProjectsDirectoryPath` is the directory path where the off-chain service code is placed. The off-chain service consists of multiple modules (projects). It should be a readable and writable directory path in the container.
* `javaProjectNamePrefix` is the name prefix of each module of the off-chain service. It is recommended to use an all-lowercase name.
* `pomGroupId` is the Maven GroupId of the off-chain service. We use Maven as the project management tool for off-chain service. It should be all lowercase and the parts should be separated by dots.

After the above command is successfully executed, two directories `move` and `rooch-java-service` should be added to the local directory `/PATH/TO/test`.

### Project Source Code Structure

Go into the `move` directory, which holds the Move contract items generated from the model. Execute the Move compile command:

```shell
rooch move build --named-addresses rooch_examples={ACCOUNT_ADDRESS}
```

If there are no surprises, the contract project can be built successfully (the last line of the output should show `Success`), but there should be some compilation warnings at this time. That's because some Move source files ending with `_logic.move` have imported (`use`) some modules that are not actually used.

At this point, you can also try to compile the off-chain service. Enter the directory `rooch-java-service` and execute `mvn compile`. If there are no surprises, the compilation should be successful.

#### Contract Project Source Code Structure

In the `move/sources` directory, all the Move source code of the on-chain contract project is included. We first ignore the files ending with `_logic.move` and introduce the other files.

* `rooch_blog_demo_init.move`. It contains the `initialize` function of the on-chain contract. Generally speaking, after the contract project is deployed on-chain, you need to call it first (only need to call it once). However, because our example project is relatively simple, so there is no meaningful initialization logic in the `initialize` function generated by the tool at present, we can ignore it for now.
* `article_aggregate.move`This is where the entry functions are located. Now it contains functions for Create, Update, Delete operations on articles and comments. You can see that the function for creating comments, an internal entity of the aggregate, is named `add_comment` instead of `create_comment`, and the function for deleting comments is named `remove_comment` instead of `delete_comment`. This is actually to make it easier to distinguish these functions as operations on internal entities of the aggregate, rather than operations on the aggregate root itself.
* `article.move`. This file contains the definition of the "data model" of the `Article` aggregate root, as well as the definition of events related to the "article" aggregate.
* `comment.move` This file contains the definition of the "data model" of the `Comment` internal entity of the aggregate.
* The following Move files do not have any complex logic, they just provide some functions that allow you to more conveniently get event property (field) values.
  * `article_created.move`
  * `article_deleted.move`
  * `article_updated.move`
  * `comment_added.move`
  * `comment_removed.move`
  * `comment_updated.move`

#### Business Logic Code

The Move source files ending with `_logic.move` are where the "business logic" implementation code is located.

If you define a method for an aggregate in a DDDML file, then dddappp tool will generate a corresponding Move code file named `{aggregate_name_method_name}_logic.move` for you, and then you need to fill in "business logic" implementation code in this file.

However, we use a preprocessor called `MOVE_CRUD_IT` above to go one step further and automatically generate default implementations for simple CRUD methods. Of course, we can check these "filled-in default logics" and modify them as needed.

After generating a project using the above model, there are already existing "business logic" code files:

* `article_add_comment_logic.move`
* `article_delete_logic.move`
* `article_update_comment_logic.move`
* `article_create_logic.move`
* `article_remove_comment_logic.move`
* `article_update_logic.move`

Now open them and remove those redundant `use` statements. If your IDE has some Move language plugins installed, you may only need to use the "format" feature to reformat these source files.

Then use `rooch move build` command to recompile Move project. Now there should be no warning messages.

## Test Application

### Run Rooch Server and Publish Contracts

First, run a local Rooch server:

```shell
rooch server start
```

Publish Move contracts:

```shell
rooch move publish --named-addresses rooch_examples={ACCOUNT_ADDRESS}
```

When you see something like this output (`status` is `executed`), you can confirm that the publish operation has been executed successfully:

```shell
{
  //...
  "execution_info": {
    //...
    "status": {
      "type": "executed"
    }
  },
  //...
}
```

### Use CLI Tools to Test Contracts

We will use Rooch CLI and other command line tools (`curl`, `jq`) to test the published contracts below.

Use `rooch move run` command to submit a transaction and initialize the contract (note to replace the placeholder `{ACCOUNT_ADDRESS}` with one of your account addresses):

```shell
rooch move run --function {ACCOUNT_ADDRESS}::rooch_blog_demo_init::initialize --sender-account {ACCOUNT_ADDRESS}
```

#### CRUD Article

##### Create Article

You can use Rooch CLI to submit a transaction like this to create a test article:

```shell
rooch move run --function {ACCOUNT_ADDRESS}::article_aggregate::create --sender-account {ACCOUNT_ADDRESS} --args 'string:Hello' 'string:World!'
```

Then you can change the content of the first parameter (title) and the second parameter (body) after `--args`, and create a few more articles.

##### READ Article

Now, you can query events and get the `ObjectID` of the created article:

```shell
curl --location --request POST 'http://localhost:50051' \
--header 'Content-Type: application/json' \
--data-raw '{
 "id":101,
 "jsonrpc":"2.0",
 "method":"rooch_getEventsByEventHandle",
 "params":["{ACCOUNT_ADDRESS}::article::ArticleCreated", null, 1000]
}'
```

You can add a pipe operation (` | jq '.result.data[0].parsed_event_data.value.id.value.vec[0]'` at the end of the above command to quickly filter out the ObjectID of the first article.

> **Tip**
>
> Before using the `jp` command (jq - commandline JSON processor), you may need to install it on your machine first.

The command with `jp` processing looks like this:

```shell
curl --location --request POST 'http://localhost:50051' \
--header 'Content-Type: application/json' \
--data-raw '{
 "id":101,
 "jsonrpc":"2.0",
 "method":"rooch_getEventsByEventHandle",
 "params":["{ACCOUNT_ADDRESS}::article::ArticleCreated", null, 1000]
}' | jq '.result.data[0].parsed_event_data.value.id.value.vec[0]'
```

Then, you can use Rooch CLI to query the object state (note to replace the placeholder `{ARTICLE_OBJECT_ID}` with the ObjectID of the article obtained above):

```shell
rooch object --id {ARTICLE_OBJECT_ID}
```

##### Update Article

You can submit a transaction like this to update an article:

```shell
rooch move run --function {ACCOUNT_ADDRESS}::article_aggregate::update --sender-account {ACCOUNT_ADDRESS} --args 'object_id:{ARTICLE_OBJECT_ID}' 'string:Foo' 'string:Bar'
```

In addition to using Rooch CLI, you can also query the object state by calling JSON RPC:

```shell
curl --location --request POST 'http://127.0.0.1:50051/' \
--header 'Content-Type: application/json' \
--data-raw '{
 "id":101,
 "jsonrpc":"2.0",
 "method":"rooch_getAnnotatedStates",
 "params":["/object/{ARTICLE_OBJECT_ID}"]
}'
```

##### Delete Article

You can submit a transaction like this to delete an article:

```shell
rooch move run --function {ACCOUNT_ADDRESS}::article_aggregate::delete --sender-account {ACCOUNT_ADDRESS} --args 'object_id:{ARTICLE_OBJECT_ID}'
```

#### CRUD Comment

##### Add Comment

Let's get the ObjectID of another article (note the path parameter `.result.data[1]` in the `jq` command below, we intend to get the information of the "second" ArticleCreated event):

```shell
curl --location --request POST 'http://localhost:50051' \
--header 'Content-Type: application/json' \
--data-raw '{
 "id":101,
 "jsonrpc":"2.0",
 "method":"rooch_getEventsByEventHandle",
 "params":["{ACCOUNT_ADDRESS}::article::ArticleCreated", null, 1000]
}' | jq '.result.data[1].parsed_event_data.value.id.value.vec[0]'
```

Then, we can use this article's ObjectID to add a comment to it (note to replace the placeholder `{ARTICLE_OBJECT_ID}` with the ObjectID of the "second" article obtained above):

```shell
rooch move run --function {ACCOUNT_ADDRESS}::article_aggregate::add_comment --sender-account {ACCOUNT_ADDRESS} --args 'object_id:{ARTICLE_OBJECT_ID}' 'u64:1' 'string:Anonymous' 'string:"A test comment"'
```

We can add a few more comments to this article by executing commands like this (note to modify the second parameter after `--args`, which is the comment sequence number):

```shell
rooch move run --function {ACCOUNT_ADDRESS}::article_aggregate::add_comment --sender-account {ACCOUNT_ADDRESS} --args 'object_id:{ARTICLE_OBJECT_ID}' 'u64:2' 'string:Anonymous2' 'string:"A test comment2"'
```

##### Read Comment

In our contract code, when a comment is added to an article, a `CommentTableItemAdded` event is emitted, which contains the ObjectID of the current article and the key (i.e. `comment_seq_id`) added to its comment table.

So, by querying events, we know which comments an article has:

```shell
curl --location --request POST 'http://localhost:50051' \
--header 'Content-Type: application/json' \
--data-raw '{
 "id":101,
 "jsonrpc":"2.0",
 "method":"rooch_getEventsByEventHandle",
 "params":["{ACCOUNT_ADDRESS}::article::CommentTableItemAdded", null, 10000]
}' | jq '.result.data[] | select(.parsed_event_data.value.article_id == "{ARTICLE_OBJECT_ID}")'
```

In our Move contract, all comments of an article are stored in a field of type `Table<u64, Comment>` embedded in the article object.

We can query the specific information of a comment through JSON RPC. To get an item in a comment table, you need to provide two parameter values: table handle and item key.

First, we need to get the handle of an article's comment table:

```shell
curl --location --request POST 'http://127.0.0.1:50051/' \
--header 'Content-Type: application/json' \
--data-raw '{
 "id":101,
 "jsonrpc":"2.0",
 "method":"rooch_getAnnotatedStates",
 "params":["/object/{ARTICLE_OBJECT_ID}"]
}' | jq '.result[0].move_value.value.value.value.comments.value.handle'
```

We already know that the `comment_seq_id` (i.e. the table item key) of the comment we created above is a `u64` integer value `1`.

Then, we can get the specific information of the comment by the following way (note to replace the placeholder `{COMMENT_TABLE_HANDLE}` with the handle of the "comment table" obtained above):

```shell
curl --location --request POST 'http://127.0.0.1:50051/' \
--header 'Content-Type: application/json' \
--data-raw '{
 "id":101,
 "jsonrpc":"2.0",
 "method":"rooch_getAnnotatedStates",
 "params":["/table/{COMMENT_TABLE_HANDLE}/0x0100000000000000"]
}'
```

Note that in the above command, the table key in the path parameter (the part after `{COMMENT_TABLE_HANDLE}/`), is the BCS serialization result of the key value represented as a hexadecimal string.

For example, the BCS serialization result of a `u64` integer value `1`, represented as a hexadecimal string, is `0x0100000000000000`.

##### Update Comment

We can submit a transaction like this to update a comment:

```shell
rooch move run --function {ACCOUNT_ADDRESS}::article_aggregate::update_comment --sender-account {ACCOUNT_ADDRESS} --args 'object_id:{ARTICLE_OBJECT_ID}' 'u64:1' 'string:Anonymous' 'string:"Updated test comment"'
```

Then we can query the comment state again to see if the comment content has been updated:

```shell
curl --location --request POST 'http://127.0.0.1:50051/' \
--header 'Content-Type: application/json' \
--data-raw '{
 "id":101,
 "jsonrpc":"2.0",
 "method":"rooch_getAnnotatedStates",
 "params":["/table/{COMMENT_TABLE_HANDLE}/0x0100000000000000"]
}'
```

##### Remove Comment

Submit a transaction to remove a comment:

```shell
rooch move run --function {ACCOUNT_ADDRESS}::article_aggregate::remove_comment --sender-account {ACCOUNT_ADDRESS} --args 'object_id:{ARTICLE_OBJECT_ID}' 'u64:1'
```

Execute the `curl` command above to query the comment again, and this time it will return something like this:

```json
{"jsonrpc":"2.0","result":[null],"id":101}
```

~~Because we still have undeleted comments for this article later, trying to delete it now should not succeed. Try executing:~~：

```shell
rooch move run --function {ACCOUNT_ADDRESS}::article_aggregate::delete --sender-account {ACCOUNT_ADDRESS} --args 'object_id:{ARTICLE_OBJECT_ID}'
```

The returned transaction execution status should be failed:

```json
//[TBD]
```

### One More Thing

If you are interested, you can refer to ["A Rooch Demo"](https://github.com/dddappp/A-Rooch-Demo#configure-off-chain-service) for instructions on how to configure the Java off-chain service in the `rooch-java-service` directory and then run it.

By querying the RESTful API of the off-chain service, you can easily query the specific information of articles and comments without using the `curl` and `jp` commands introduced above.


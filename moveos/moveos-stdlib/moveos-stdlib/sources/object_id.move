// Copyright (c) RoochNetwork
// SPDX-License-Identifier: Apache-2.0

module moveos_std::object_id {
    use std::hash;
    use std::vector;
    use moveos_std::bcs;
    use moveos_std::type_info;
    use moveos_std::address;

    friend moveos_std::context;
    friend moveos_std::account_storage;
    friend moveos_std::storage_context;
    friend moveos_std::event;
    friend moveos_std::table;
    friend moveos_std::type_table;
    friend moveos_std::object_table;
    friend moveos_std::object;
  
    /// ObjectID is a unique identifier for the Object
    struct ObjectID has store, copy, drop {
        id: address,
    }

    public fun id(object_id: &ObjectID): address {
        object_id.id
    }

    /// UID is a unique identifier, it can be `drop`,but can not be `copy` or `store`
    /// And it only can be generated by the `&mut Context`, consumered by `Object` or `Table` new function.
    struct UID has drop{
        id: ObjectID,
    }

    public fun uid_to_object_id(uid: UID): ObjectID {
        uid.id
    }

    public(friend) fun new_uid(id: ObjectID): UID {
        UID{id}
    }

    struct TypedUID<phantom T> has drop {
        id: ObjectID,
    }

    public(friend) fun new_typed_uid<T>(id: ObjectID): TypedUID<T> {
        TypedUID{id}
    }

    public fun typed_uid_id<T>(typed_uid: &TypedUID<T>): ObjectID {
        typed_uid.id
    }

    /// Generate a new ObjectID from an address
    public(friend) fun address_to_object_id(address: address): ObjectID {
        ObjectID { id: address }
    }

    public fun named_object_id<T>(): ObjectID {
        address_to_object_id(
            address::from_bytes(
                hash::sha3_256(
                    *std::string::bytes(&type_info::type_name<T>())
                )
            )
        )
    }

    public fun account_named_object_id<T>(account: address): ObjectID {
        let bytes = bcs::to_bytes(&account);
        vector::append(&mut bytes, *std::string::bytes(&type_info::type_name<T>()));
        address_to_object_id(
            address::from_bytes(
                hash::sha3_256(bytes)
            )
        )
    }

    public fun custom_object_id<ID: drop, T>(id: ID): ObjectID {
        let bytes = bcs::to_bytes(&id);
        vector::append(&mut bytes, *std::string::bytes(&type_info::type_name<T>()));
        let hash = hash::sha3_256(bytes);
        address_to_object_id(address::from_bytes(hash))
    }
}

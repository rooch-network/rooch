---
title: 简单的，深入的，丑陋的交互式证明
description: "让我们从 1+1 开始，以追问的方式展开对交互式证明的思辨。"
author: popcnt
category: Technology
date: 2023/08/21
---

import Image from "next/image";
import PostHeader from "/components/blog/postHeader";

<PostHeader />

## 1 简单

交互式证明，又名交互式游戏，已经成为 Optimistic Rollups 仲裁机制的事实上的标准。通过使用中间指令为链上和链下提供统一的确定性单步执行环境，最大限度地减少链上仲裁期间的资源需求。它固有的复杂性导致我们为了传播和理解而简化其解释。让我们深入研究一下它到底有多简单[^1]。

### 1.1 同一语言，同一结果

**Moe**：`Uno mas uno es igual a dos` 在你的电脑上也成立吗？

**Joe**：我不懂西班牙语，你什么意思？你能用大家都能理解的数学语言描述一下吗？

----

**Moe**：`1 + 1 = 2` 在你的电脑上也成立吗？

**Joe**：Yes！

----

**Moe**：`1 + 1 = 2` 在每个人的计算机上都成立吗？

**Everyone**：Yes！

----

**Moe**：`(((1 + 1) + 1) + 1) = 4 ` 在每个人的计算机上也成立吗？

每个人：Yes！

### 1.2 同一语言，步骤，两种结果

**Moe**：`(((1 + 1) + 1) + 1) = 5 ` 在你的电脑上也成立吗？

**Joe**：不！它是 4。

----

**Moe**：我倾向于断言 5 的正确性。我们是否应该请求尊敬的学者洛伦兹[^2]来判定我们的主张的真实性？

**Joe**：好的。然而，由于洛伦兹先生相当专注，我们可以首先检查第一个不一致的步骤，并将其验证委托给他。

----

**Moe**：这行得通吗？

**Joe**：可以。每一步都是确定性的。

----

**Moe**：让我们从第一次评测开始吧！

**Joe**：Okay！

……

**Moe** & **Joe**：在第 2 步中，我们得到了不同的结果。A 是 `2 + 1 = 4`，B 是 `2 +1 = 3`。我们来寻求他的帮助吧！

**Lorentz**：`2 + 1 = 3`

**Moe** & **Joe**：感谢！

### 1.3 同一语言，步骤，两种结果，LogN 次核对

**Moe**：`(((1 + 1) + 1) + ... + 1) = 48784359345934` 在你的电脑上也成立吗？

**Joe**：不。它的值是 `48784359345935`。

----

**Moe**：我们再玩一次游戏吧！

**Joe**：决不！由于通信开销，每次比较需要 1 秒。我们可能需要 150 万年才能完成游戏。

----

**Moe**：计算成本仅为 1 秒。Emmmm，使用二分法怎么样？

**Joe**：每次比较都可以解决一半的问题。通过这种方式，我们可以快速识别不一致的地方！

----

**Moe**：第 24392179672966 步是 `24392179672966 + 1 = 24392179672967`

**Joe**：第 24392179672966 步是 `24392179672965 + 1 = 24392179672966`

----

**Moe**：第 12196089836483 步是 `12196089836483 + 1 = 12196089836484`

**Joe**：第 12196089836483 步是 `12196089836482 + 1 = 12196089836483`

----

**Moe**：第 6098044918241 步是 `6098044918241 + 1 = 6098044918242`

**Joe**：第 6098044918241 步是 `6098044918241 + 1 = 6098044918242`。第一个不一致的步骤一定在 `(6098044918241, 12196089836483]`，我们离目的地不远了！

## 2 深入

在“简单”中，我们确定了构成“交互式游戏”的三个基本要素：

> a. 一种语言

> b. 确定性步骤

> c. 二分法

人们不禁会想，这么一个简单的协议是如何让众多的 Optimistic Rollups 团队花费如此多的时间和精力的呢？这就像莱特兄弟发明飞机之前的时代一样，当时人们已经知道从 A 点到 B 点最快的方法不是翻山越岭，而是直线飞行。飞行的动作就像二分法一样简单明了。为了吸引那些以前开车改坐飞机的人，强调这一点就足够了。然而，对于一名飞机工程师来说，显然还有更多东西需要了解。

### 2.1 同一语言

**Moe**：我们需要一种支持区块链客户端操作并产生与链上客户端一致的结果的语言。

**Joe**：没问题！对于以太坊来说，就是 Solidity！

----

**Moe**：您打算如何处理这些依赖于时空的指令？如：CALLER、SLOAD、SSTORE、BLOCKTIME。

**Joe**：嗯……我现在不能告诉你，但总有办法的，不是吗？

----

**Moe**：Optimism 曾尝试过这一点，但失败了。

**Joe**：悲剧。感谢他们的贡献。

----

**Moe**：我们可以模拟一种语言的执行容器。 EVM-in-EVM 怎么样？

**Joe**：听起来不错。但是 Gas 成本怎么样？我认为在 Solidity 中模拟内存和存储并不是一件容易的事。

----

**Moe**：我们需要一种媒介，就像我们对数学语言所做的那样。

**Joe**：我认为我们已经接近答案了。

----

**Moe**：客户端可以编译为这种语言。我们可以在链上模拟这种语言。

**Joe**：理想情况下，它应该是一种汇编语言，因为模拟指令的执行总是更简单。

### 2.2 确定性步骤

**Moe**：通过使用某种语言，我们可以大致实现计算的确定性。因此，现在要解决的问题是输入和状态变化的确定性。

**Joe**：一般来说，我们使用 Oracle 来解决与外部信息输入相关的问题。

----

**Moe**：这个 Oracle 对于 L1 和 L2 都具有确定性吗？

**Joe**：我们在 L1 上有根（哈希），这意味着我们有机会验证输入。

----

**Moe**：能否用一个数字来说明我们目前取得的成就？

**Joe**：当然！

<Image
  src="/blog/interactive-game/timeline.png"
  alt="timeline"
  width={500}
  height={300}
  className="mx-auto my-8"
/>

----

**Moe**：您能进一步解释一下这个数字吗？

**Joe**：

> 预执行：通过 `block_hash` 获取输入

> 加载模拟器：设置执行环境

> 验证输入：与见证人验证输入

> 转换：执行 L2 交易

----

**Moe**：听起来我们已经拥有了一切！

**Joe**：差不多了。

### 2.3 对分法

**Moe**：作为最直接的部分，似乎没有什么值得讨论的。

**Joe**：我们需要确定证人的真实性。

----

**Moe**：签名还不够吗？

**Joe**：不够。有些人可能会选择装聋作哑。

----

**Moe**：好的。L1 应在每一平分轮中验证见证人。

**Joe**：是的。并且 L1 不仅可以具有不一致的 STEP<sub>i</sub>，还可以具有二分后最后一致的 STEP<sub>i-1</sub>。

## 3 丑陋

在“深入”中，我们提炼出了构成“交互式游戏”的三个基本要素：

> a. 一种语言：简单的汇编，可以在链下客户端运行并在链上进行模拟。

> b. 确定性步骤：与见证人验证输入。

> c. 二分法：在每一轮中验证见证人。

到目前为止，交互式游戏一直是可爱且复杂的。然而，为了让它真正发挥作用，我们必须揭开它丑陋的一面。

### 3.1 同一语言：RISC

**Moe**：看来我们有很多选择，比如 MIPS、RISC-V，甚至 Wasm。

**Joe**：我们可以设计一个灵活的架构来支持各种语言。然而，在任何给定时刻只能使用一个。

----

**Moe**：哪一个是你的首选？

**Joe**：MIPS。但两年后将会是 RISC-V。

----

**Moe**：你的不可预测性让我感到困惑。

**Joe**：我是一个讲道理的人，我正要向你解释我的理由。首先，模拟 CPU 指令的抽象级别相当低。虽然它可能看起来很深奥，但由于缺乏多层抽象，它实际上需要较少的认知负担，因此我对 Wasm 缺乏热情。

----

**Moe**：这似乎相当合理。

**Joe**：在 CPU 指令集中，RISC 指令集无疑是一个更优越的选择，因为它的指令数量有限且稳定，并且避免了模拟复杂指令的复杂性。特别是，加载-存储架构可以防止 ALU 操作中内存副作用的出现。值得注意的是，我们的模拟器中内存状态变化的每一步都需要跟踪，因此实现寄存器内存架构的困难可能只会导致无限的错误。考虑到编译器的成熟度和稳定性，我倾向于MIPS。

----

**Moe**：告诉我更多有关 RISC-V 的信息。

**Joe**：我们可以拥有 64 位地址空间，因为 MIPS 32 位提供的 4GB 内存空间有时会不够用。然而，无论使用什么指令集，我们都必须小心验证实现的正确性。

----

**Moe**：系统调用将如何实现？事实上，这可能会带来一个棘手的问题。

**Joe**：但是，我们可以巧妙地构建我们的程序来最大限度地减少系统调用的使用，部署我们自己的系统调用实现来替换通用的系统调用实现。我们的首要需求是保持链上链下状态变化的一致性，而不是创建一个通用模拟器。

----

**Moe**：当我提到系统调用时，我实际上指的是语言中的非确定性因素。系统调用代表模拟器与外部世界之间的一种交互形式，这种交互可能意味着非确定性。您提到了最小化和定制系统调用的方法，虽然不具体，但考虑到模拟器的所有方面都掌握在实现者手中，这确实是可行的。但我还是很担心，觉得还有很多不确定因素没有考虑到。

**Joe**：我理解你的担忧，你甚至已经开始考虑下一阶段的问题了。让我们首先假设我们已经拥有这样的媒介，并在下一节中继续讨论。

----

**Moe**：中间人代表似乎对所有链都是公正的，这听起来非常有希望。

**Joe**：确实如此。我们可以在各个链上实现它的模拟器，从而使各个链能够进行交互式游戏。我听说过一个项目就是这样做的。

----

**Moe**：[Rooch/flexEmu](https://github.com/rooch-network/flexEmu)

**Joe**：正是如此！

### 3.2 确定性步骤：过程，输入

**Moe**：我们快点进行吧，因为前面关于语言的部分还没有充分讨论。

**Joe**：确实，我们需要更深入地研究语言的确定性。

----

**Moe**：当我们讨论汇编语言的确定性时，实际上是在讨论指令的确定性。

**Joe**：指令由操作码和操作数组成。这是确定性问题的两个主要来源：程序的微观表现和指令级别的输入。我们已经简要讨论了“深入”中的输入，并将很快深入进行详细分析。首先，我们需要保证指令副作用的唯一性。

----

**Moe**：并发将是一个严重的问题。

**Joe**：是的。仿真器产生的输出（状态根）必须与生产环境中并行执行器计算的输出相同。

----

**Moe**：如何保证每一步并发执行的确定性？

**Joe**：Dr.Strange[^3] 可以帮助我们。

----

**Moe**：你是认真的？

**Joe**：不，我是乔。我们不能这样做，我们的目的也不是建立这样一个系统。我们想要的是在模拟器之间获得相同的最终状态并保持相同的步骤状态。

----

**Moe**：哦，是的。达到同样的最终状态并不是一件难事。我们只需要……

**Joe**：排序器应该给每个交易一个订单号。因果无关的交易可以并行执行，而因果相关的交易必须严格按顺序执行。这样，最终状态将与全局顺序执行一致。

----

**Moe**：现在，我们可以自信地消除并发对指令副作用的影响。

**Joe**：除了并发交易之外，流程中还有很多并发执行单元。

----

**Moe**：最简单的方法是强制模拟器在单个线程上执行。

**Joe**：是的。

----

**Moe**：随机性是另一个不稳定因素。

**Joe**：让我们开始自下而上分析指令世界。

----

**Moe**：RISC 家族中没有直接支持随机操作的操作码。对于相关的系统调用，我们可以在模拟器中嵌入固定的随机数据源。这样，每个仿真器都可以在同一过程中获得一致的伪随机数。

**Joe**：没什么问题。

----

**Moe**：Linux 内核讨厌浮动。模拟器也讨厌这个吗？

**Joe**：我们可以使用 SoftFloat 库，也可以直接禁止它。

----

**Moe**：听起来我们已经为确定性程序做好了一切准备。

**Joe**：还不够。不要忘记程序不能证明自己的清白。

----

**Moe**：L1 可以验证静态过程，只需要摘要。在交互式游戏开始之前，L1 合约将通过验证双方的记忆状态来验证双方是否使用了一致的程序。

**Joe**：确实如此。这类似于可验证的启动过程。引导扇区的内存地址是固定的，双方只需要提供简单的 merkle 树证明即可。

----

**Moe**：您刚才提到，关于输入问题还有一些补充意见。

**Joe**：确实如此。我想重申可验证的“输入过程验证”的重要性。输入的链下验证过程必须是单步可追溯的，以便输入的初始状态合法化。作为内存状态的一部分，如果加载的输入数据被故意篡改，将导致无法提供状态树的证明，因为篡改意味着前面的指令产生了副作用。然而，在初始状态一致的情况下，恶意节点无法提供副作用指令来证明自己的清白。

----

**Moe**：听起来确实有点绕，但我明白你的意思。关键是要保证输入的确定性，结合过程的确定性，我们只能有确定性的单步状态。看起来坚不可摧。

**Joe**：我们还有“无意识的邪恶”的问题，这是一个很容易被忽视的问题。

----

**Moe**：作为你的对手，我理解你的观点。实现确定性意味着我们正在实现依赖于物理媒介的纯粹理性。仅仅拥有纯粹的理性不应该导致自满，导致我们忽视物理的限制。

**Joe**：没错。区块链网络能够抵御无声错误，因为节点在验证过程中提供了充足的冗余。然而，简单的区块链本身并不具备这个属性。在 L2 的异步验证中，无声错误可能会导致诚实但错误的节点受到惩罚。

----

**Moe**：无声错误的发生就像太阳从东边升起、西边落下一样不可避免。因此，我们需要主动创造冗余。例如，我们可以利用不同架构的物理机来集中计算同一个过程，并将聚合结果作为当前节点的输出。云服务提供商已经精通类似的任务。

**Joe**：现在我们可以说我们已经有了确定性的步骤。

### 3.3 二分法：: 头等舱机票

**Moe**：二分是讨论最多的话题，因为它是交互式游戏中的直接挑战。不过，现在看来已成定局。

**Joe**：这是一个直接的问题，因为它直接表现出交互行为，但答案是间接的。它依赖于适当的中间语言媒介和确定性语言执行的实现。

----

**Moe**：这让我想起之前关于飞机的比喻。现在我们有了飞机，我们只需要购买机票即可。

**Joe**：给我一张头等舱的票，谢谢！

## 附录 A：当模拟器在模拟时它在模拟什么

**Joe**：这次让我开始吧。

**Moe**：继续吧。

----

**Moe**：观察这个源代码在你的机器上会变成什么样的指令：

<Image
  src="/blog/interactive-game/ones-count.png"
  alt="ones-count"
  width={600}
  height={300}
  className="mx-auto my-8"
/>


**Joe**：你又抢先说话了。在我的 `x86_64` 上：

<Image
  src="/blog/interactive-game/ones-count-x86.png"
  alt="ones-count-x86"
  width={600}
  height={600}
  className="mx-auto my-8"
/>

或：

<Image
  src="/blog/interactive-game/ones-count-simd.png"
  alt="ones-count-simd"
  width={600}
  height={276}
  className="mx-auto my-8"
/>

----

**Moe**：因为我给你看了源代码。说话很便宜。在我的 RISC-V 上：

<Image
  src="/blog/interactive-game/ones-count-riscv.png"
  alt="ones-count-riscv"
  width={283}
  height={600}
  className="mx-auto my-8"
/>

**Joe**：面对相同的输入，尽管我们的机器执行的指令存在巨大差异，但它们仍然设法产生相同的输出。

----

**Moe**：是你在模仿我，还是我在模仿你？

**Joe**：这就是问题所在。

----

[^1]: 必备知识：了解 Optimistic Rollup 的基本概念，以及 L1 和 L2 的基本组成部分。

[^2]: 一位科学家的故事与以太交织在一起。

[^3]: 史蒂芬·斯特兰奇博士是漫威漫画出版的美国漫画中出现的一个能够控制时空的角色。

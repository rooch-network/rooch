---
title: 简单的，深入的，丑陋的交互式证明
description: "让我们从 1+1 开始，以追问的方式展开对交互式证明的思辨。"
author: popcnt
category: Technology
date: 2023/08/21
---

import Image from "next/image";
import PostHeader from "/components/blog/postHeader";

<PostHeader />

## 1 简单

交互式证明，又名交互式游戏，已经成为 Optimistic Rollups 仲裁机制的事实上的标准。通过使用中间指令为链上和链下提供统一的确定性单步执行环境，最大限度地减少链上仲裁期间的资源需求。它固有的复杂性导致我们为了传播和理解而简化其解释。让我们深入研究一下它到底有多简单[^1]。

### 1.1 同一语言，同一结果

**Moe**：`Uno mas uno es igual a dos` 在你的电脑上也成立吗？

**Joe**：我不懂西班牙语，你什么意思？你能用大家都能理解的数学语言描述一下吗？

----

**Moe**：`1 + 1 = 2` 在你的电脑上也成立吗？

**Joe**：Yes！

----

**Moe**：`1 + 1 = 2` 在每个人的计算机上都成立吗？

**Everyone**：Yes！

----

**Moe**：`(((1 + 1) + 1) + 1) = 4 ` 在每个人的计算机上也成立吗？

每个人：Yes！

### 1.2 同一语言，步骤，两种结果

**Moe**：`(((1 + 1) + 1) + 1) = 5 ` 在你的电脑上也成立吗？

**Joe**：不！它是 4。

----

**Moe**：我倾向于断言 5 的正确性。我们是否应该请求尊敬的学者洛伦兹[^2]来判定我们的主张的真实性？

**Joe**：好的。然而，由于洛伦兹先生相当专注，我们可以首先检查第一个不一致的步骤，并将其验证委托给他。

----

**Moe**：这行得通吗？

**Joe**：可以。每一步都是确定性的。

----

**Moe**：让我们从第一次评测开始吧！

**Joe**：Okay！

……

**Moe** & **Joe**：在第 2 步中，我们得到了不同的结果。A 是 `2 + 1 = 4`，B 是 `2 +1 = 3`。我们来寻求他的帮助吧！

**Lorentz**：`2 + 1 = 3`

**Moe** & **Joe**：感谢！

### 1.3 同一语言，步骤，两种结果，LogN 次核对

**Moe**：`(((1 + 1) + 1) + ... + 1) = 48784359345934` 在你的电脑上也成立吗？

**Joe**：不。它的值是 `48784359345935`。

----

**Moe**：我们再玩一次游戏吧！

**Joe**：决不！由于通信开销，每次比较需要 1 秒。我们可能需要 150 万年才能完成游戏。

----

**Moe**：计算成本仅为 1 秒。Emmmm，使用二分法怎么样？

**Joe**：每次比较都可以解决一半的问题。通过这种方式，我们可以快速识别不一致的地方！

----

**Moe**：第 24392179672966 步是 `24392179672966 + 1 = 24392179672967`

**Joe**：第 24392179672966 步是 `24392179672965 + 1 = 24392179672966`

----

**Moe**：第 12196089836483 步是 `12196089836483 + 1 = 12196089836484`

**Joe**：第 12196089836483 步是 `12196089836482 + 1 = 12196089836483`

----

**Moe**：第 6098044918241 步是 `6098044918241 + 1 = 6098044918242`

**Joe**：第 6098044918241 步是 `6098044918241 + 1 = 6098044918242`。第一个不一致的步骤一定在 `(6098044918241, 12196089836483]`，我们离目的地不远了！

## 2 深入

在“简单”中，我们确定了构成“交互式游戏”的三个基本要素：

> a. 一种语言

> b. 确定性步骤

> c. 二分法

人们不禁会想，这么一个简单的协议是如何让众多的 Optimistic Rollups 团队花费如此多的时间和精力的呢？这就像莱特兄弟发明飞机之前的时代一样，当时人们已经知道从 A 点到 B 点最快的方法不是翻山越岭，而是直线飞行。飞行的动作就像二分法一样简单明了。为了吸引那些以前开车改坐飞机的人，强调这一点就足够了。然而，对于一名飞机工程师来说，显然还有更多东西需要了解。

### 2.1 同一语言

**Moe**：我们需要一种支持区块链客户端操作并产生与链上客户端一致的结果的语言。

**Joe**：没问题！对于以太坊来说，就是 Solidity！

----

**Moe**：您打算如何处理这些依赖于时空的指令？如：CALLER、SLOAD、SSTORE、BLOCKTIME。

**Joe**：嗯……我现在不能告诉你，但总有办法的，不是吗？

----

**Moe**：Optimism 曾尝试过这一点，但失败了。

**Joe**：悲剧。感谢他们的贡献。

----

**Moe**：我们可以模拟一种语言的执行容器。 EVM-in-EVM 怎么样？

**Joe**：听起来不错。但是 Gas 成本怎么样？我认为在 Solidity 中模拟内存和存储并不是一件容易的事。

----

**Moe**：我们需要一种媒介，就像我们对数学语言所做的那样。

**Joe**：我认为我们已经接近答案了。

----

**Moe**：客户端可以编译为这种语言。我们可以在链上模拟这种语言。

**Joe**：理想情况下，它应该是一种汇编语言，因为模拟指令的执行总是更简单。

### 2.2 确定性步骤

**Moe**：通过使用某种语言，我们可以大致实现计算的确定性。因此，现在要解决的问题是输入和状态变化的确定性。

**Joe**：一般来说，我们使用 Oracle 来解决与外部信息输入相关的问题。

----

**Moe**：这个 Oracle 对于 L1 和 L2 都具有确定性吗？

**Joe**：我们在 L1 上有根（哈希），这意味着我们有机会验证输入。

----

**Moe**：能否用一个数字来说明我们目前取得的成就？

**Joe**：当然！

<Image
  src="/blog/interactive-game/timeline.png"
  alt="timeline"
  width={500}
  height={300}
  className="mx-auto my-8"
/>

----

**Moe**：您能进一步解释一下这个数字吗？

**Joe**：

> 预执行：通过 `block_hash` 获取输入

> 加载模拟器：设置执行环境

> 验证输入：与见证人验证输入

> 转换：执行 L2 交易

----

**Moe**：听起来我们已经拥有了一切！

**Joe**：差不多了。

### 2.3 对分法

**Moe**：作为最直接的部分，似乎没有什么值得讨论的。

**Joe**：我们需要确定证人的真实性。

----

**Moe**：签名还不够吗？

**Joe**：不够。有些人可能会选择装聋作哑。

----

**Moe**：好的。L1 应在每一平分轮中验证见证人。

**Joe**：是的。并且 L1 不仅可以具有不一致的 STEP<sub>i</sub>，还可以具有二分后最后一致的 STEP<sub>i-1</sub>。

## 3 丑陋

在“深入”中，我们提炼出了构成“交互式游戏”的三个基本要素：

> a. 一种语言：简单的汇编，可以在链下客户端运行并在链上进行模拟。

> b. 确定性步骤：与见证人验证输入。

> c. 二分法：在每一轮中验证见证人。

到目前为止，交互式游戏一直是可爱且复杂的。然而，为了让它真正发挥作用，我们必须揭开它丑陋的一面。

### 3.1 同一语言：RISC

**Moe**：看来我们有很多选择，比如 MIPS、RISC-V，甚至 Wasm。

**Joe**：我们可以设计一个灵活的架构来支持各种语言。然而，在任何给定时刻只能使用一个。

----

**Moe**：哪一个是你的首选？

**Joe**：MIPS。但两年后将会是 RISC-V。

----

**Moe**：你的不可预测性让我感到困惑。

**Joe**：我是一个讲道理的人，我正要向你解释我的理由。首先，模拟 CPU 指令的抽象级别相当低。虽然它可能看起来很深奥，但由于缺乏多层抽象，它实际上需要较少的认知负担，因此我对 Wasm 缺乏热情。

----

**Moe**：这似乎相当合理。

**Joe**：在 CPU 指令集中，RISC 指令集无疑是一个更优越的选择，因为它的指令数量有限且稳定，并且避免了模拟复杂指令的复杂性。特别是，加载-存储架构可以防止 ALU 操作中内存副作用的出现。值得注意的是，我们的模拟器中内存状态变化的每一步都需要跟踪，因此实现寄存器内存架构的困难可能只会导致无限的错误。考虑到编译器的成熟度和稳定性，我倾向于MIPS。

----

**Moe**：告诉我更多有关 RISC-V 的信息。

**Joe**：我们可以拥有 64 位地址空间，因为 MIPS 32 位提供的 4GB 内存空间有时会不够用。然而，无论使用什么指令集，我们都必须小心验证实现的正确性。

----

**Moe**：: How will system calls be implemented? Indeed, it could pose a
formidable issue. 

**Joe**：: However, we can cleverly construct our program to minimize the use 
of system calls, deploying our own system call implementations to replace
generic ones. Our primary demand is to maintain consistency in state
changes on and off the chain, rather than to create a universal emulator.

----

**Moe**：: When I mention system calls, I am actually referring to the
non-deterministic factors in the language. System calls represent a form
of interaction between the emulator and the outside world, and such
interaction could imply non-determinism. You mentioned the method of
minimizing and customizing system calls, which, while not specific, is
indeed feasible considering that all aspects of the emulator lie in the
hands of the implementer. However, I remain apprehensive, feeling that
there are many non-deterministic factors that I have not yet considered.

**Joe**：: I perceive your concerns, and you have even begun contemplating
issues of the next phase. Let us first postulate that we already possess
such a medium and continue this discussion in the following section.

----

**Moe**：: The intermediary representation appears to be impartial towards all
chains, which sounds immensely promising.

**Joe**：: Indeed. We can implement its emulator on various chains, thus
enabling various chains to have an Interactive Game. I've heard of a
project that's doing just that.

----

**Moe**：: [Rooch/flexEmu](https://github.com/rooch-network/flexEmu)

**Joe**：: Exactly it!

### 3.2 确定性步骤：: 过程, 输入

**Moe**：: Let's proceed swiftly, as the earlier segment regarding language
has not yet been fully discussed.

**Joe**：: Indeed, we need to delve deeper into the determinacy of language.

----

**Moe**：: When we discuss the determinacy of assembly language, we are in
fact addressing the determinacy of instructions.

**Joe**：: Instruction is composed of opcode and operand. These are the two
primary sources of determinacy issues: the micro-level manifestations of
procedure and input at the level of instructions. We have briefly
discussed input in 'The Seasoned' and will delve into a detailed
analysis shortly. First, we need to ensure the uniqueness of instruction
side effects.

----

**Moe**：: Concurrency will be a serious issue.

**Joe**：: Yes. The output (state root) produced by emulator must be as same
as the one calculated by parallel executor in production environment.

----

**Moe**：: How do we ensure the determinacy of concurrent execution in every
step?

**Joe**：: Dr.Strange[^3] could help us.

----

**Moe**：: Are you serious?

**Joe**：: No, I'm Joe. We can't do that, and our purpose is not to build such a
system. What we want is to get the same final state and maintain the
same step state among emulators.

----

**Moe**：: Oh, yes. It's not a hard job to achieve the same final state. We
just need...

**Joe**：: Sequencer should give each tx an order number. Tx that are causally
unrelated can be executed in parallel, while those that are causally
related must be executed strictly in sequence. In this manner, the final
state will be consistent with a global sequential execution.

----

**Moe**：: Now, we can confidently eliminate the impact of concurrency on the
side effects of instructions.

**Joe**：: In addition to concurrent transactions, there are many units of
concurrent execution in the process.

----

**Moe**：: The easiest way to do this is to force the emulator to execute
on a single thread.

**Joe**：: Yes.

----

**Moe**：: Randomness is another element of instability.

**Joe**：: Let's start analysing the world of instructions from the bottom
up.

----

**Moe**：: There is no opcode supporting random operation directly in RISC
family. For related system calls, we can embed a fixed random data
source within the emulator. This way, each emulator can achieve
consistent pseudorandom numbers in the same procedure.

**Joe**：: Nothing wrong with.

----

**Moe**：: Linux Kernel hates float. Does emulator hate that too?

**Joe**：: We could use SoftFloat Library or just forbidden it.

----

**Moe**：: Sounds like we've prepared everything for deterministic procedure.

**Joe**：: Not enough yet. Do not forget that procedures cannot prove their
own innocence.

----

**Moe**：: L1 can validate static procedures, requiring only a digest. Prior
to the commencement of the Interactive Game, the L1 contract will verify
whether a consistent procedure has been used by the two parties through
the validation of their memory states.

**Joe**：: Indeed. This is akin to a verifiable boot process. The memory
address of the boot sector is fixed, and both parties only need to
provide a simple merkle tree proof.

----

**Moe**：: You just mentioned that there are
additional points to be made regarding the issue with input.

**Joe**：: Indeed. I would like to reiterate the importance of the verifiable
'verification of the input process'. The off-chain verification
process for input must be traceable in single steps, so that the initial
state of the input can be legitimized. As part of the memory state, if
the input data loaded is deliberately tampered with, it will lead to the
inability to provide a proof of the state tree, as tampering implies
that the preceding instructions have produced side effects. However, in
the case of consistent initial states, malicious nodes cannot provide
side effect instructions to prove their innocence.

----

**Moe**：: It does sound a bit convoluted, but I comprehend your meaning. The
crux is to ensure the determinacy of the input, and combined with the
determinacy of the procedure, we can only have deterministic single-step
states. It seems impregnable.

**Joe**：: We also have the issue of 'Unconscious Evil', a problem that is
easily overlooked.

----

**Moe**：: As your counterpart, I understand
your point. Achieving determinacy means we are implementing pure
rationality that relies on a physical medium. Possessing pure
rationality alone should not lead to complacency, causing us to overlook
the physical constraints.

**Joe**：: Exactly. Blockchain networks are resilient to silent errors, as
nodes provide ample redundancy in the verification process. However, the
simple blockchain itself does not possess this property. In the
asynchronous validation of L2, silent errors can result in honest but
erroneous nodes being penalized.

----

**Moe**：: The occurrence of silent errors is as inevitable as the sun rising
in the east and setting in the west. Therefore, we need to proactively
create redundancy. For instance, we can utilize physical machines with
different architectures to collectively compute the same process, and
use the aggregated results as the output of the current node. Cloud
service providers are already well-versed in similar tasks.

**Joe**：: Now we can say we have deterministic step.

### 3.3 二分法：: 头等舱机票

**Moe**：: Bisection is the most discussed topic as it is a direct challenge
in the interactive game. However, it now seems to be a foregone
conclusion.

**Joe**：: It is a direct issue as it directly exhibits the interactive
behaviors, yet the answer is indirect. It relies on an appropriate
intermediary language medium and the implementation of deterministic
language execution.

----

**Moe**：: This reminds me of the previous analogy about airplanes. Now we
have the airplane, we just need to purchase the tickets.

**Joe**：: Give me a first-class ticket, thank you!

## 附录 A：: 当模拟器在模拟时它在模拟什么

**Joe**：: Let me start this time.

**Moe**：: Go ahead.

----

**Moe**：: Observe what instructions this source code will morph into on your
machine:

<Image
  src="/blog/interactive-game/ones-count.png"
  alt="ones-count"
  width={600}
  height={300}
  className="mx-auto my-8"
/>


**Joe**：: You've preemptively spoken again. On my x86_64:

<Image
  src="/blog/interactive-game/ones-count-x86.png"
  alt="ones-count-x86"
  width={600}
  height={600}
  className="mx-auto my-8"
/>

Or：

<Image
  src="/blog/interactive-game/ones-count-simd.png"
  alt="ones-count-simd"
  width={600}
  height={276}
  className="mx-auto my-8"
/>

----

**Moe**：: Because I showed you source code. Talking is cheap. On my RISC-V:

<Image
  src="/blog/interactive-game/ones-count-riscv.png"
  alt="ones-count-riscv"
  width={283}
  height={600}
  className="mx-auto my-8"
/>

**Joe**：: In the face of identical inputs, despite the vast differences in
the instructions our machines execute, they still manage to yield
identical outputs.

----

**Moe**：: Is it you who is mirroring me, or am I the one replicating you?

**Joe**：: That is the question.

----

[^1]: Prerequisite knowledge: Understand the basic concepts of
optimistic rollups, and the fundamental components of L1 and L2.

[^2]: A scientist with a narrative intertwined with Ether.

[^3]: Doctor Stephen Strange is a character who can control time-space
appearing in American comic books published by Marvel Comics.
